<html>
<head>
	<title>Map Quiz: cities</title>
</head>
<body bgcolor="#FFFFFF" marginheight="0" marginwidth="0" topmargin="0" leftmargin="0">

<div id="quiz">
	<h1 id="quiz-title" style="margin: 10px;">Silk Road Map Quizzes: cities</h1>
	<div id="instructions"></div>
	<div id="quiz-choice" style="margin: 10px;">
		<select id="fileDropdown"></select>
	</div>
	<div id="map-container" style="margin: 10px;">
			<img src="./img/cities.jpg" id="map-img" usemap="#img-map" style="z-index:0;">
			<map id="img-map" name="img-map"></map>
			<div id="answers" style="position:absolute; left:0px; top:0px;"></div>
			<canvas id="map-canvas" style="position:absolute; pointer-events: none;"></canvas>
			<div id="control-form" style="text-align: center;">
				<form name="controls">
					<span style="font-size: 18px; font-family: Helvetica;">Find</span>
					&nbsp;
					<input type="text" id="locationToFind" name="locationToFind" size="15">
					<br/>
					<input type="button" value="     Skip     " onClick="skip();">
					<input type="button" value="     Show     " onClick="showLocation();">
					<input type="button" value="  Start Over  " onClick="resetQuiz();">
					<input type="button" value="     Quit     " onClick="window.close();">
				</form>
				<p id="feedback"></p>
			</div>
			<div id="copyright">
				<p style="text-align: center;">Â© 2002 Lance Jenott for the 
					<a href="https://depts.washington.edu/silkroad/" target="_blank">Silk Road Seattle</a> project 
					<br/>(updated by Peter Verkinderen)
				</p>
			</div>
	</div>
</div>

<script language="Javascript">

	var arrayPos=0;
	var skipped = [];
	var found = [];
	var errors = [];
	var editMode = false;
	var showingLoc = false;
	var features, featureNamesShuffled, quizName;

	document.getElementById("fileDropdown").addEventListener("change", e => resetQuiz(e.target.value));

	document.addEventListener("keydown", function (e) {
        if (e.ctrlKey && e.key === "e") {
            console.log("Edit Mode!")
            e.preventDefault();
            editMode = !editMode;
        }
    });

	document.onload = initialize();

	document.getElementById("map-img").addEventListener("load", e => resize());


	async function initialize() {
		let initialQuizDataPath = await populateDropdown();
		let data = await setPageData(initialQuizDataPath);		
	}

	async function fetchJsonFile(filepath) {
		data = await fetch(filepath).then(res => res.json());
		console.log(data);
		return data;
	}
    
    // Populate the dropdown menu with all available quizzes:
    async function populateDropdown() {
        // Clear existing options
		const fileDropdown = document.getElementById('fileDropdown');
        fileDropdown.innerHTML = '';

        // Add options for each file in the "coords" folder (starting with the current file)
        const fileList = await fetchJsonFile("./file_list.json");
		const currentFilename = window.location.pathname.split("/").pop().split(".")[0];
		const fileListWithoutCurrent = fileList.filter(path => !(path.includes(currentFilename)));
		const fileListCurrent = fileList.filter(path => (path.includes(currentFilename)));
		[fileListCurrent, fileListWithoutCurrent].forEach((lst) => {
			lst.forEach((filename) => {
                const option = document.createElement('option');
                option.value = filename;
                option.text = filename.split("/")[filename.split("/").length-1].split(".")[0];
                fileDropdown.appendChild(option);
            });
		});

		return fileDropdown.value;
		
    }

	// set the size of the map container and canvas to the size of the image:
	function resize(){
		let mapImg = document.getElementById("map-img");
		let bbox = mapImg.getBoundingClientRect();
		console.log("bbox:");
		console.log(bbox);
		let mapCont = document.getElementById("map-container");
		mapCont.style.width = bbox.width;
		mapCont.style.height = bbox.height;
		let controlForm = document.getElementById("control-form");
		controlForm.style.width = bbox.width;
		let canvas = document.getElementById("map-canvas");
		canvas.style.width = bbox.width;
		canvas.width = bbox.width;
		canvas.height = bbox.height;
		console.log(bbox.width);
		canvas.style.height = bbox.height;
		canvas.style.left = bbox.x;
		canvas.style.top = bbox.y;
	}

	// Inject the quiz data into the page
	async function setPageData(dataPath) {
		quizName = dataPath.split("/").pop().split(".")[0];

		// get the data from the json file:
		data = await fetchJsonFile(dataPath);

		// define the map's features:
		features = data["mapping"];
		featureNamesShuffled = shuffleArray(Object.keys(features));

		// set the page title:
		document.getElementsByTagName("title")[0].innerHTML=`Map Quiz: ${data["quiz_name"]}`;
		document.getElementById("quiz-title").innerHTML=`Silk Roads Map Quiz: ${data["quiz_name"]}`;

		// set the map image:
		let mapImg = document.getElementById("map-img");
		mapImg.setAttribute("src", data["map_image"]);

		// build the mapping:
		buildMap(features);

		// build the controls:
		updateForm();

		// remove all existing answer annotations:
		document.getElementById("answers").innerHTML="";

		return data
	}

	// Shuffle the order of items in an array randomly
	function shuffleArray(array) {
		for (let i = array.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[array[i], array[j]] = [array[j], array[i]];
		}
		return array
	}

	/*function average(array) {
		if (array.length === 0) return 0;
		let sum = array.reduce((a,b) => parseInt(a)+parseInt(b));
		return sum / array.length;
	}
	function max(array){
		return array.reduce((a,b) => parseInt(a) > parseInt(b) ? parseInt(a) : parseInt(b));
	}
	function min(array){
		return array.reduce((a,b) => parseInt(a) > parseInt(b) ? parseInt(b) : parseInt(a));
	}*/

	// Handle clicks on the map:
	function mapclick(e, clickedId) {
		if (showingLoc) {
			console.log("you can't click the map when it's showing a place");
			return 0;
		}
		let locationToFindName = document.controls.locationToFind.value;
		let locationToFind = features[locationToFindName]
		let locationToFindID = locationToFind.id;

		if(clickedId==locationToFindID) {
			found.push(locationToFindName);
			// remove the item from the skipped list, if it was there:
			skipped = skipped.filter((item) => item !== locationToFindName);
			// show the location on the map:
			/*let coords = locationToFind.coords.split(",");
			console.log(coords);
			let x = average(coords.filter((el, idx) => idx % 2 === 0));
			console.log(coords.filter((el, idx) => idx % 2 === 0));
			console.log(x);
			let y = average(coords.filter((el, idx) => idx % 2 === 1));
			console.log(coords.filter((el, idx) => idx % 2 === 1));
			console.log(y);*/
			let answer = `<div class="answer" style="pointer-events: none; position:absolute; text-align: right; left:${e.x}px; top:${e.y}px; font-size:14px;">${locationToFindName}</div>`;
			document.getElementById("answers").innerHTML = document.getElementById("answers").innerHTML + "\n" + answer;

			// move to the next quiz question:
			advance();
		} else {
			errors.push(locationToFindName);
			updateForm();
			alert('Try Again');
		}
	}

	// Skip the question
	function skip() {
		let skippedTerm = document.controls.locationToFind.value;
		console.log("skipping", skippedTerm);
		if (!skipped.includes(skippedTerm)){
			skipped.push(skippedTerm);
		}
		console.log("You have now skipped "+ skipped.length + " places");
		
		advance()
	}

	// Move to the next question
	function advance() {
		arrayPos++;
		if(arrayPos<featureNamesShuffled.length) {
			// If we are not at the end of our list of locations in the array 
			// then assign the current location to the "Find" box.
			updateForm()
		} else if (skipped.length > 0) {
			// If we reached the end, but the user skipped places,
			// give the skipped places another go:
			arrayPos = 0;
			featureNamesShuffled = shuffleArray(skipped);
			updateForm();
			alert('Finished; going back to the ' + skipped.length + ' skipped places!')
			skipped = [];
		} else 	if (arrayPos==featureNamesShuffled.length) {
			// If we have reached the and there are no skipped places left, 
			// update the feedback and notify the user that the quiz is finished.
			updateForm() // to display the correct number of found places
			// https://stackoverflow.com/a/16605836
			const timestamp = new Date().toUTCString();
			const code = encrypt(`${JSON.stringify(errors)}_${quizName}_${timestamp}`);
			console.log(code);
			const feedback = document.getElementById("feedback");
			feedback.innerHTML = feedback.innerHTML + "<br/><b> You have finished the quiz. Copy this code: "+code+"</b>";
			//setTimeout(alert, 300, 'You finished the quiz! Copy this code: '+code);  
			// NB: timeout is needed because alert is faster than updateForm!
		}
	}

	function encrypt (text) {
		const salt = text[2]+text[4]+text[text.length-8]+text[text.length-5]; // take 4 chars from the text as key
		const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
		const byteHex = (n) => ("0" + Number(n).toString(16)).substr(-2);
		const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);

		return text
			.split("")
			.map(textToChars)
			.map(applySaltToChar)
			.map(byteHex)
			.join("") + salt;
	}

	function decrypt (encoded) {
		const salt = encoded.substr(encoded.length-4, 4);
		encoded = encoded.substr(0, encoded.length-4);
		const textToChars = (text) => text.split("").map((c) => c.charCodeAt(0));
		const applySaltToChar = (code) => textToChars(salt).reduce((a, b) => a ^ b, code);
		return encoded
			.match(/.{1,2}/g)
			.map((hex) => parseInt(hex, 16))
			.map(applySaltToChar)
			.map((charCode) => String.fromCharCode(charCode))
			.join("");
	};

	// (re)start the selected quiz:
	function resetQuiz() {
		// reset the tracking variables:
		arrayPos = 0;
		skipped = [];
		found = [];
	    errors = [];

		// get the quiz data path from the dropdown and load it:
		const fileDropdown = document.getElementById('fileDropdown');
		const dataPath = fileDropdown.value;
		setPageData(dataPath);
	}

	// build the mapping between the map image and the features:
	function buildMap(features) {
		let mapStr = "";
		for (const [name, d] of Object.entries(features)) {
		  //mapStr += `<area shape="${d.shape}" coords="${d.coords}" solution="${name}" href="javascript:mapclick(${d.id});" title="">\n`
		  // NB: using `href=` turns the cursor into a pointed finger,
		  // while using `onclick=` keeps the cursor in the same shape.
		  mapStr += `<area shape="${d.shape}" coords="${d.coords}" solution="${name}" href="#" onclick="mapclick(event, ${d.id}); return false;" title="">\n`
		}

		// insert the image map into the document:
		document.getElementById("img-map").innerHTML = mapStr;
	}

	
	// Show the location of a feature on the map for a short time:
	function showLocation() {
		showingLoc = true;
		// get the current location:
		let loc = document.getElementById("locationToFind");

		// highlight location:
		let canvas = document.getElementById("map-canvas");
		let coords = features[loc.value].coords.split(",").map(Number);
		console.log(coords);
		console.log(`canvas.width: ${canvas.width}, canvas.height: ${canvas.width}`);
        var ctx = canvas.getContext('2d');
		ctx.scale(1,1);
        ctx.fillStyle = '#f00';
        ctx.beginPath();
		if (coords.length > 4){
			console.log("draw polygon");
			ctx.moveTo(coords[0], coords[1]);
			console.log(coords[0], coords[1]);
            for(let item=2 ; item < coords.length-1 ; item+=2 ){
				console.log(coords[item], coords[item+1]);
                ctx.lineTo( coords[item] , coords[item+1] )
		    }
			ctx.closePath();
			ctx.stroke();
        } else {
			console.log("draw rectangle");
			console.log([coords[0], coords[1], coords[2]-coords[0], coords[3] - coords[1]]);
			ctx.rect(coords[0], coords[1], coords[2]-coords[0], coords[3] - coords[1]);  // x, y, width, height
			//ctx.rect(88, 80, 10, 10);
		}
		ctx.fill();

		// remove location highlight after 3 seconds:
		setTimeout(clearCanvasAndSkip, 2000, ctx, canvas);
	}

	function clearCanvasAndSkip(ctx, canvas) {
		console.log("clearing canvas");
		ctx.clearRect(0,0,canvas.width, canvas.height);
		showingLoc = false;
		skip()
	}

	// build the form that contains the quiz controls
	function updateForm(){
		// display the name of the feature:
		let featureName = featureNamesShuffled[arrayPos] === undefined ? "" : featureNamesShuffled[arrayPos];
		document.getElementById("locationToFind").setAttribute("value", featureName);
		
		// update the feedback:
		let feedback = `You have correctly identified ${found.length} of ${Object.keys(features).length} places (${skipped.length} skipped, ${errors.length} errors)`;
		document.getElementById("feedback").innerHTML = feedback;
	}



</script>


</body></html>